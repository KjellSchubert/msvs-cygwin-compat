These are tiny test projects exploring ABI compatibility between msvs and cygwin
toolchains at the C and C++ level.

Let's assume we have a Windows application whose main.c or main.cpp is supposed
to be compiled with msvs for whatever reason. Let's also assume we want this
same process to execute code compiled with some other toolchain like cygwin or
mingw or mingw64. The usual way to get code compiled with different C/C++
toolchains into the same Windows process is to have cygwin generate a C wrapper
DLL, then have msvs link against this DLL's import library. There's no way to
have MSVS call the C++ code compiled with cygwin directly. There are
potential alternatives to this DLL approach though:

msvs linking against static cygwin-generated C libs
---

This actually seems to be possible, at least in the simple ./msvs-gcc test
I set up: to repro my attempts run these steps:

* install cygwin, scons, msvs
* cd msvs-gcc
* run scons to have cygwin build lib.obj, foo.lib and bar.exe.
* run 'scons bar.exe' to verify cygwin generated a functional windows exe
* open vcxproj in msvs, compile main.c with msvs, then link against the
  cywgin-generated foo.lib. I was surprised to see msvs can link both against
  lib.obj and also foo.lib, I had not expected that cygwin ar generates a
  library format that msvs understands!

I have no idea if this approach scales to larger libs, e.g. could we have a
C program using cywgin posix threads (pthread.h) and posix sockets
(sys/sockets.h) and C99 code linked into a msvs executable using the msvs
linker. At the C level this is not especially valuable, since most 3rd party C
dependencies compile with both msvs and cygwin on Windows anyway. So not worth
investigating deeper.

BTW make sure you match up the 32/64 bit versions of cygwin & msvs properly
here, since obviously you cannit mix & match 32/64 bit objs in the same process
no matter what toolchain generated them (you get errors like 'LNK1112: module machine type 'x64' conflicts with target machine type 'X86' from 32/64bit
mismatches).

msvs linking against shared/dynamic cygwin-generated C libs
---

* cd msvs-gcc
* 'scons bar_shared.exe' to have cygwin build bar_shared.dll and bar_shared.exe

But how can we link against foo_shared.dll in msvs? Note that cygwin only
generates a foo_shared.dll, but no accompanying import library (which msvs
needs for linking). See https://cygwin.com/faq/faq.html#TOC102 : so we
have to generate a .def file from the dll, then an msvs import lib from the
.def, and then also mess with cygwin_crt0() if cygwin1.dll was being used.
See also http://stackoverflow.com/questions/9946322/how-to-generate-an-import-library-lib-file-from-a-dll:

>bash foo_shared_import.sh

Then build bar_shared.vcxproj with msvs 2012 (make sure you pick the correct
win32 or x64 target), then run debug\bar_shared.exe to verify this executes
fine, then run 'depends debug\bar_shared.exe' to verify which DLLs the exe
depends on (and that mingw DLL build depends on msvcrt.dll, whereas cygwin
DLL build depends on cygwin1.dll).

Other useful tools:

>dumpbin /symbols
>dumpbin /exports
>dumpbin /headers  # shows x64 vs x86 machine format
>depends.exe  # shows DLL deps

msvs linking against static cygwin-generated C++ libs
---

This is what actually would be highly valuable, since there are plenty of
C++ libraries out there that don't compile easily with msvs and would be
pretty expensive to port to msvs. So compiling these libs with cygwin and then
having msvs link against these static libs would be great to have. Sadly this
didn't work in the small test I ran: this is a variant of the (successful)
C-level link test:

* cd msvs-c++
* run 'scons bar.exe' to have cygwin build lib.o, foo.lib and bar.exe.
* run bar.exe to verify cygwin generated a functional windows exe
* open vcxproj in msvs, compile main.c with msvs, then link against the
  cywgin-generated foo.lib. An extra complication to the C sample is that
  we have to link against cygwin's C++ libstd++.a. Sadly msvs chokes on this
  library, I'm not sure why, but didn't expect this work anyway, despite name
  mangling and EH differences not being an issue here (e.g. msvs's
  LTCG makes this impossible in the opposite direction). The error I get is
  "LNK1143: invalid or corrupt file: no symbol for COMDAT section 0x5".
  No idea how to avoid this error, I doubt this is easily possible. In any case
  the traditional DLL route seems much cleaner to begin with, that way the
  toolchain linkers don't have to touch C++ files generated by other toolchains,
  which sounds like a recipe for chaos to me.
